<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SUPER JOSEY BUILDER</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            touch-action: none; /* Prevents zooming/scrolling on mobile */
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            display: block;
            image-rendering: pixelated; 
            background-color: #87CEEB; 
            max-width: 100%;
            max-height: 100vh;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            font-weight: bold;
            pointer-events: none;
            font-size: 14px;
            z-index: 10;
        }
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 100;
            text-align: center;
        }
        
        /* --- MOBILE CONTROLS CSS --- */
        #mobile-controls {
            display: none; /* Hidden on desktop by default */
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let touches pass through to buttons */
            z-index: 50;
        }

        /* Only show controls on screens smaller than 800px */
        @media (max-width: 800px) {
            #mobile-controls { display: block; }
        }

        .control-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            pointer-events: auto; /* Re-enable clicks */
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 18px;
            touch-action: none;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.5);
        }

        /* D-PAD */
        #btn-left { bottom: 30px; left: 20px; }
        #btn-right { bottom: 30px; left: 100px; }

        /* ACTIONS */
        #btn-jump { bottom: 30px; right: 20px; background: rgba(0, 255, 0, 0.2); } /* Z - Greenish */
        #btn-attack { bottom: 30px; right: 100px; background: rgba(255, 0, 0, 0.2); } /* X - Reddish */
        
        /* BUILD MENU (Top Right) */
        #btn-build { 
            bottom: 110px; 
            right: 20px; 
            width: 50px; height: 50px; 
            background: rgba(255, 255, 0, 0.2); 
            border-radius: 10px; /* Square */
            font-size: 12px;
        }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="640" height="360"></canvas>
    
    <div id="ui-overlay">
        <div>SCORE: <span id="score">0</span></div>
        <div>WOOD: <span id="wood">0</span>/99</div>
    </div>

    <!-- MOBILE CONTROLS -->
    <div id="mobile-controls">
        <div id="btn-left" class="control-btn">←</div>
        <div id="btn-right" class="control-btn">→</div>
        <div id="btn-attack" class="control-btn">X</div>
        <div id="btn-jump" class="control-btn">Z</div>
        <div id="btn-build" class="control-btn">BLD</div>
    </div>

    <div id="start-screen" onclick="startGame()">
        <h1>SUPER JOSEY BUILDER</h1>
        <p>TAP TO START</p>
        <p>Mobile: Use on-screen buttons</p>
        <p>Desktop: Arrows, Z, X, C</p>
    </div>
</div>

<script>
/* ---------------------------------------------------
   GAME ENGINE & CONSTANTS
   ---------------------------------------------------
*/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const woodEl = document.getElementById('wood');
const startScreen = document.getElementById('start-screen');

// Game State
let gameActive = false;
let lastTime = 0;
let timeScale = 1.0;
let globalScore = 0;
let woodInventory = 0;
let currentLevel = 1;

// Inputs
const keys = {
    ArrowLeft: false,
    ArrowRight: false,
    ArrowUp: false,
    ArrowDown: false,
    z: false, // Jump
    x: false, // Attack
    c: false  // Build
};

// Audio Context
let audioCtx;

function initAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;

    if (type === 'jump') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'hammer') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.2);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'bonk') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.1);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'crunch') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, now);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
    } else if (type === 'gunshot') {
        const bufferSize = audioCtx.sampleRate * 0.5;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }
        const noise = audioCtx.createBufferSource();
        noise.buffer = buffer;
        noise.connect(gain);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        noise.start(now);
    } else if (type === 'build') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(880, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    } else if (type === 'error') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.setValueAtTime(80, now + 0.1);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
    }
}

/* ---------------------------------------------------
   ENTITIES & CLASSES
   ---------------------------------------------------
*/

class Entity {
    constructor(x, y, w, h, color) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.markedForDeletion = false;
    }
    
    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
    }
    
    update(dt, blocks) {}
}

class Block extends Entity {
    constructor(x, y, w, h, type) {
        super(x, y, w, h, '#654321');
        this.type = type; 
        if (type === 'solid') this.color = '#5c4033'; 
        if (type === 'jumpthru') this.color = '#8b4513'; 
        if (type === 'spike') this.color = '#888'; 
    }

    draw(ctx, camX, camY) {
        super.draw(ctx, camX, camY);
        if (this.type === 'solid') {
            ctx.fillStyle = '#228b22';
            ctx.fillRect(this.x - camX, this.y - camY, this.w, 4);
        }
        if (this.type === 'spike') {
            ctx.fillStyle = '#aaa';
            ctx.beginPath();
            ctx.moveTo(this.x - camX, this.y + this.h - camY);
            ctx.lineTo(this.x + this.w/2 - camX, this.y - camY);
            ctx.lineTo(this.x + this.w - camX, this.y + this.h - camY);
            ctx.fill();
        }
    }
}

class WoodPile extends Entity {
    constructor(x, y) {
        super(x, y, 32, 16, '#deb887');
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + 8 - camX, this.y + 8 - camY, 6, 0, Math.PI*2);
        ctx.arc(this.x + 16 - camX, this.y + 4 - camY, 6, 0, Math.PI*2);
        ctx.arc(this.x + 24 - camX, this.y + 8 - camY, 6, 0, Math.PI*2);
        ctx.fill();
    }
}

class Particle extends Entity {
    constructor(x, y, vx, vy, life, color) {
        super(x, y, 4, 4, color);
        this.vx = vx;
        this.vy = vy;
        this.life = life;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.markedForDeletion = true;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 48, '#000'); 
        this.speed = 200;
        this.jumpForce = -450;
        this.gravity = 1200;
        this.facing = 1; 
        this.idleTimer = 0;
        this.huntingSequence = false;
        this.attackTimer = 0;
        this.buck = null; 
    }

    update(dt, blocks) {
        if (!this.huntingSequence) {
            if (keys.ArrowRight) { this.vx = this.speed; this.facing = 1; }
            else if (keys.ArrowLeft) { this.vx = -this.speed; this.facing = -1; }
            else { this.vx = 0; }

            if (keys.z && this.grounded) {
                this.vy = this.jumpForce;
                this.grounded = false;
                playSound('jump');
                keys.z = false; 
            }

            if (keys.x && this.attackTimer <= 0) {
                this.attackTimer = 0.2; 
                playSound('hammer');
            }
            if (this.attackTimer > 0) this.attackTimer -= dt;
        }

        this.vy += this.gravity * dt;
        this.x += this.vx * dt;
        this.handleCollisions(blocks, 'x');
        this.y += this.vy * dt;
        this.handleCollisions(blocks, 'y');

        if (this.y > 1000) {
            this.respawn();
        }

        if (Math.abs(this.vx) < 1 && this.grounded && !this.huntingSequence) {
            this.idleTimer += dt;
            if (this.idleTimer > 5) {
                this.startHuntingSequence();
            }
        } else {
            this.idleTimer = 0;
        }
    }

    startHuntingSequence() {
        this.huntingSequence = true;
        this.buck = {
            x: this.x + (this.facing * 200),
            y: this.y,
            w: 32, h: 32,
            state: 'alive',
            life: 2.0 
        };
    }

    handleHuntingLogic(dt) {
        if (!this.huntingSequence || !this.buck) return;
        
        this.buck.life -= dt;

        if (this.buck.life <= 0 && this.buck.state === 'alive') {
            playSound('gunshot');
            this.buck.state = 'dead';
            setTimeout(() => {
                this.huntingSequence = false;
                this.buck = null;
                this.idleTimer = 0;
            }, 1000);
        }
    }

    handleCollisions(blocks, axis) {
        this.grounded = false;
        for (let block of blocks) {
            if (checkOverlap(this, block)) {
                if (block.type === 'spike') {
                    this.respawn();
                    return;
                }
                
                if (block instanceof LevelSign) {
                    block.trigger();
                    return;
                }

                if (axis === 'x') {
                    if (this.vx > 0) this.x = block.x - this.w;
                    if (this.vx < 0) this.x = block.x + block.w;
                    this.vx = 0;
                } else {
                    if (this.vy > 0) { 
                        if (block.type === 'jumpthru' && this.y + this.h - (this.vy * 0.05) > block.y) {
                            continue;
                        }
                        this.y = block.y - this.h;
                        this.grounded = true;
                        this.vy = 0;
                    } else if (this.vy < 0 && block.type === 'solid') { 
                        this.y = block.y + block.h;
                        this.vy = 0;
                    }
                }
            }
        }
    }

    respawn() {
        this.x = 50;
        this.y = 200;
        this.vx = 0;
        this.vy = 0;
        scoreEl.innerText = globalScore; 
    }

    draw(ctx, camX, camY) {
        const cx = this.x - camX;
        const cy = this.y - camY;

        if (this.huntingSequence) {
            ctx.fillStyle = 'brown';
            ctx.fillRect(cx + (this.facing*10), cy + 20, 20, 4);
        }

        ctx.fillStyle = '#ff0000';
        ctx.fillRect(cx, cy, 24, 8);
        ctx.fillRect(cx + (this.facing === 1 ? 16 : -4), cy + 4, 12, 4); 

        ctx.fillStyle = '#ffccaa';
        ctx.fillRect(cx + 4, cy + 8, 16, 10);

        ctx.fillStyle = '#fff';
        ctx.fillRect(cx + 2, cy + 18, 20, 16);

        ctx.fillStyle = '#55aaff';
        ctx.fillRect(cx + 2, cy + 34, 20, 8);

        ctx.fillStyle = '#654321';
        ctx.fillRect(cx + 2, cy + 42, 8, 6);
        ctx.fillRect(cx + 14, cy + 42, 8, 6);

        if (this.attackTimer > 0) {
            ctx.fillStyle = '#888'; 
            const hx = this.facing === 1 ? cx + 24 : cx - 16;
            const hy = cy + 20;
            ctx.fillRect(hx, hy, 16, 10);
            ctx.fillStyle = '#654321'; 
            ctx.fillRect(hx + 6, hy + 10, 4, 10);
        }

        if (this.huntingSequence && this.buck) {
            const bx = this.buck.x - camX;
            const by = this.buck.y - camY + 16; 
            
            ctx.fillStyle = '#d2b48c';
            if (this.buck.state === 'alive') {
                ctx.fillRect(bx, by, 30, 20); 
                ctx.fillRect(bx, by-10, 10, 10); 
                ctx.fillStyle = '#fff'; 
                ctx.fillRect(bx, by-16, 2, 6);
                ctx.fillRect(bx+4, by-16, 2, 6);
            } else {
                ctx.fillRect(bx, by+10, 30, 10); 
            }
        }
    }
}

class Brother extends Entity {
    constructor(x, y, type) {
        super(x, y, 24, 48, '#f0f');
        this.type = type; 
        this.startX = x;
        this.patrolDist = 100;
        this.timer = 0;
        this.isBonked = false;
    }

    bonk() {
        if (this.isBonked) return;
        this.isBonked = true;
        this.vx = 400; 
        this.vy = -400; 
        playSound('bonk');
        particles.push(new Particle(this.x, this.y - 10, 0, -10, 1, 'red'));
    }

    update(dt, blocks) {
        if (this.isBonked) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vy += 800 * dt; 
            if (this.y > 1000) this.markedForDeletion = true;
            return;
        }

        if (this.type === 'pat') {
            if (!this.dir) this.dir = -1;
            this.x += 30 * this.dir * dt;
            if (Math.abs(this.x - this.startX) > this.patrolDist) this.dir *= -1;
        }
        
        if (this.type === 'josh') {
            this.timer += dt;
            if (this.timer > 3) {
                this.timer = 0;
                projectiles.push(new Projectile(this.x, this.y, player.x, player.y));
            }
        }
    }

    draw(ctx, camX, camY) {
        const cx = this.x - camX;
        const cy = this.y - camY;

        ctx.fillStyle = '#ddd';
        ctx.fillRect(cx, cy, 24, 48);

        if (this.type === 'alan') {
            ctx.fillStyle = '#333'; 
            ctx.fillRect(cx+2, cy+18, 20, 16);
            ctx.fillStyle = '#000'; 
            ctx.fillRect(cx+4, cy+10, 16, 4);
            ctx.fillStyle = '#00f'; 
            ctx.fillRect(cx+18, cy+18, 6, 12);
        } else if (this.type === 'pat') {
            ctx.fillStyle = '#005500'; 
            ctx.fillRect(cx, cy, 24, 6);
            ctx.fillStyle = '#00f'; 
            ctx.fillRect(cx+2, cy+34, 20, 14);
            ctx.fillStyle = '#aaf';
            ctx.fillRect(cx+8, cy+25, 8, 6);
        } else if (this.type === 'josh') {
            ctx.fillStyle = '#000'; 
            ctx.fillRect(cx, cy, 24, 10);
            ctx.fillRect(cx+8, cy-4, 8, 4); 
            ctx.fillStyle = 'orange'; 
            ctx.fillRect(cx, cy+6, 24, 2);
        }
        
        if (this.isBonked) {
            ctx.fillStyle = 'red';
            ctx.fillText('#$@!', cx, cy - 10);
        }
    }
}

class Projectile extends Entity {
    constructor(x, y, targetX, targetY) {
        super(x, y, 12, 12, 'purple');
        const angle = Math.atan2(targetY - y, targetX - x);
        this.vx = Math.cos(angle) * 150;
        this.vy = Math.sin(angle) * 150;
        this.life = 5;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.markedForDeletion = true;
        
        if (checkOverlap(this, player)) {
            player.vy = -200;
            player.vx = this.vx > 0 ? 200 : -200;
            this.markedForDeletion = true;
        }
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = 'purple';
        ctx.beginPath();
        ctx.arc(this.x+6 - camX, this.y+4 - camY, 6, 0, Math.PI, true);
        ctx.fill();
        ctx.fillRect(this.x+4 - camX, this.y+4 - camY, 4, 8);
    }
}

class LevelSign extends Entity {
    constructor(x, y) {
        super(x, y, 40, 40, 'red');
        this.triggered = false;
        this.text = "CONDEMNED";
    }
    trigger() {
        if (this.triggered) return;
        this.triggered = true;
        this.text = "SOLD";
        playSound('build');
        setTimeout(() => {
            alert("LEVEL COMPLETE! Starting Over...");
            setupLevel();
        }, 2000);
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = '#8B4513'; 
        ctx.fillRect(this.x + 16 - camX, this.y - camY, 8, 40);
        
        ctx.fillStyle = this.triggered ? 'green' : 'red';
        ctx.fillRect(this.x - camX, this.y - 10 - camY, 40, 20);
        
        ctx.fillStyle = 'white';
        ctx.font = '8px Courier';
        ctx.fillText(this.text, this.x + 2 - camX, this.y + 2 - camY);
    }
}

/* ---------------------------------------------------
   GAME LOGIC
   ---------------------------------------------------
*/

let player;
let entities = [];
let blocks = [];
let projectiles = [];
let particles = [];

function checkOverlap(rect1, rect2) {
    return (rect1.x < rect2.x + rect2.w &&
            rect1.x + rect1.w > rect2.x &&
            rect1.y < rect2.y + rect2.h &&
            rect1.y + rect1.h > rect2.y);
}

function setupLevel() {
    player = new Player(50, 200);
    blocks = [];
    entities = [];
    projectiles = [];
    particles = [];
    woodInventory = 0;
    woodEl.innerText = woodInventory;

    blocks.push(new Block(0, 300, 2000, 60, 'solid'));
    
    blocks.push(new Block(300, 200, 100, 20, 'jumpthru'));
    blocks.push(new Block(500, 150, 100, 20, 'jumpthru'));
    blocks.push(new Block(700, 250, 20, 50, 'solid')); 

    blocks.push(new Block(800, 290, 100, 20, 'spike'));

    entities.push(new WoodPile(150, 284));
    entities.push(new WoodPile(320, 184));
    entities.push(new WoodPile(600, 284));
    entities.push(new WoodPile(950, 284));

    entities.push(new Brother(450, 252, 'alan')); 
    entities.push(new Brother(600, 252, 'pat')); 
    entities.push(new Brother(520, 102, 'josh')); 

    blocks.push(new LevelSign(1200, 260));
}

function buildSystem(dt) {
    if (keys.c) {
        timeScale = 0.1;
        if (keys.ArrowRight) {
            if (!keys.buildLock) {
                if (woodInventory >= 20) {
                    woodInventory -= 20;
                    woodEl.innerText = woodInventory;
                    playSound('build');
                    const buildX = player.facing === 1 ? player.x + 40 : player.x - 60;
                    const newBlock = new Block(buildX, player.y + 20, 60, 10, 'solid');
                    newBlock.color = '#CD853F'; 
                    
                    if (!checkOverlap(newBlock, player)) {
                        blocks.push(newBlock);
                    } else {
                        woodInventory += 20; 
                        playSound('error');
                    }
                } else {
                    playSound('error');
                }
                keys.buildLock = true;
            }
        } else {
            keys.buildLock = false;
        }
    } else {
        timeScale = 1.0;
    }
}

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dtRaw = (timestamp - lastTime) / 1000;
    lastTime = timestamp;
    
    const dt = Math.min(dtRaw, 0.1) * timeScale;

    if (gameActive) {
        buildSystem(dt);
        player.update(dt, blocks);
        if (player.huntingSequence) player.handleHuntingLogic(dt);

        if (player.attackTimer > 0) {
            const hitX = player.facing === 1 ? player.x + 24 : player.x - 24;
            const hammerBox = {x: hitX, y: player.y + 10, w: 24, h: 24};
            
            entities.forEach(e => {
                if (e instanceof Brother && checkOverlap(hammerBox, e)) {
                    e.bonk();
                }
                if (e instanceof WoodPile && !e.markedForDeletion && checkOverlap(hammerBox, e)) {
                    e.markedForDeletion = true;
                    woodInventory = Math.min(woodInventory + 10, 99);
                    woodEl.innerText = woodInventory;
                    playSound('crunch');
                    
                    for(let i=0; i<5; i++) {
                        particles.push(new Particle(e.x, e.y, Math.random()*100-50, -Math.random()*100, 0.5, '#deb887'));
                    }
                }
            });
        }

        entities.forEach(e => e.update(dt, blocks));
        projectiles.forEach(p => p.update(dt));
        particles.forEach(p => p.update(dt));

        entities = entities.filter(e => !e.markedForDeletion);
        projectiles = projectiles.filter(p => !p.markedForDeletion);
        particles = particles.filter(p => !p.markedForDeletion);

        let camX = player.x - canvas.width/2;
        let camY = player.y - canvas.height/2;
        camY = Math.min(Math.max(camY, 0), 500);
        camX = Math.max(camX, 0);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        blocks.forEach(b => b.draw(ctx, camX, camY));
        entities.forEach(e => e.draw(ctx, camX, camY));
        projectiles.forEach(p => p.draw(ctx, camX, camY));
        player.draw(ctx, camX, camY);
        particles.forEach(p => p.draw(ctx, camX, camY));

        if (keys.c) {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#333';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.fillRect(player.x - camX - 60, player.y - camY - 80, 140, 60);
            ctx.strokeRect(player.x - camX - 60, player.y - camY - 80, 140, 60);
            
            ctx.fillStyle = '#fff';
            ctx.font = '10px Courier';
            ctx.fillText("BUILD MODE", player.x - camX - 50, player.y - camY - 65);
            ctx.fillText("Press -> to Build", player.x - camX - 55, player.y - camY - 50);
            ctx.fillText("PLANK (20 Wood)", player.x - camX - 55, player.y - camY - 35);
        }
    }

    requestAnimationFrame(gameLoop);
}

/* ---------------------------------------------------
   INPUT HANDLING (KEYBOARD & TOUCH)
   ---------------------------------------------------
*/

function startGame() {
    initAudio();
    startScreen.style.display = 'none';
    gameActive = true;
    setupLevel();
    requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.key === 'ArrowRight') keys.ArrowRight = true;
    if (e.key === 'ArrowUp') keys.ArrowUp = true;
    if (e.key === 'ArrowDown') keys.ArrowDown = true;
    if (e.key.toLowerCase() === 'z') keys.z = true;
    if (e.key.toLowerCase() === 'x') keys.x = true;
    if (e.key.toLowerCase() === 'c') keys.c = true;
});

window.addEventListener('keyup', (e) => {
    if (e.key === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.key === 'ArrowRight') keys.ArrowRight = false;
    if (e.key === 'ArrowUp') keys.ArrowUp = false;
    if (e.key === 'ArrowDown') keys.ArrowDown = false;
    if (e.key.toLowerCase() === 'z') keys.z = false;
    if (e.key.toLowerCase() === 'x') keys.x = false;
    if (e.key.toLowerCase() === 'c') keys.c = false;
});

// Touch Handler
function bindTouch(id, key) {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        keys[key] = true; 
    });
    btn.addEventListener('touchend', (e) => { 
        e.preventDefault(); 
        keys[key] = false; 
    });
}

bindTouch('btn-left', 'ArrowLeft');
bindTouch('btn-right', 'ArrowRight');
bindTouch('btn-jump', 'z');
bindTouch('btn-attack', 'x');
bindTouch('btn-build', 'c');

</script>
</body>
</html>
